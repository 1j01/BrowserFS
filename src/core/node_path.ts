// Generated by CoffeeScript 1.6.2
(function() {
  var __slice = [].slice;

  BrowserFS.node.path = (function() {
    function path() {}

    path.normalize = function(p) {
      var absolute, c, components, goodComponents, idx, _i, _len;

      if (p === '') {
        p = '.';
      }
      absolute = p.charAt(0) === path.sep;
      p = path._removeDuplicateSeps(p);
      components = p.split(path.sep);
      goodComponents = [];
      for (idx = _i = 0, _len = components.length; _i < _len; idx = ++_i) {
        c = components[idx];
        if (c === '.') {
          continue;
        } else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {
          goodComponents.pop();
        } else {
          goodComponents.push(c);
        }
      }
      if (!absolute && goodComponents.length < 2) {
        switch (goodComponents.length) {
          case 1:
            if (goodComponents[0] === '') {
              goodComponents.unshift('.');
            }
            break;
          default:
            goodComponents.push('.');
        }
      }
      p = goodComponents.join(path.sep);
      if (absolute && p.charAt(0) !== path.sep) {
        p = path.sep + p;
      }
      return p;
    };

    path.join = function() {
      var paths, processed, segment, _i, _len;

      paths = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      processed = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        segment = paths[_i];
        if (typeof segment !== 'string') {
          throw new TypeError("Invalid argument type to path.join: " + (typeof segment));
        } else if (segment !== '') {
          processed.push(segment);
        }
      }
      return path.normalize(processed.join(path.sep));
    };

    path.resolve = function() {
      var cwd, p, paths, processed, resolved, _i, _len;

      paths = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      processed = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        p = paths[_i];
        if (typeof p !== 'string') {
          throw new TypeError("Invalid argument type to path.join: " + (typeof p));
        } else if (p !== '') {
          if (p.charAt(0) === path.sep) {
            processed = [];
          }
          processed.push(p);
        }
      }
      resolved = path.normalize(processed.join(path.sep));
      if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {
        return resolved.substr(0, resolved.length - 1);
      }
      if (resolved.charAt(0) !== path.sep) {
        if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {
          resolved = resolved.length === 1 ? '' : resolved.substr(2);
        }
        cwd = BrowserFS.node.process.cwd();
        if (resolved !== '') {
          resolved = BrowserFS.node.path.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);
        } else {
          resolved = cwd;
        }
      }
      return resolved;
    };

    path.relative = function(from, to) {
      var downSegs, fromSegs, i, rv, seg, toSegs, upCount, _i, _j, _len;

      from = path.resolve(from);
      to = path.resolve(to);
      fromSegs = from.split(path.sep);
      toSegs = to.split(path.sep);
      toSegs.shift();
      fromSegs.shift();
      upCount = 0;
      downSegs = [];
      for (i = _i = 0, _len = fromSegs.length; _i < _len; i = ++_i) {
        seg = fromSegs[i];
        if (seg === toSegs[i]) {
          continue;
        }
        upCount = fromSegs.length - i;
        break;
      }
      downSegs = toSegs.slice(i);
      if (fromSegs.length === 1 && fromSegs[0] === '') {
        upCount = 0;
      }
      if (upCount > fromSegs.length) {
        upCount = fromSegs.length;
      }
      rv = '';
      for (i = _j = 0; 0 <= upCount ? _j < upCount : _j > upCount; i = 0 <= upCount ? ++_j : --_j) {
        rv += '../';
      }
      rv += downSegs.join(path.sep);
      if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {
        rv = rv.substr(0, rv.length - 1);
      }
      return rv;
    };

    path.dirname = function(p) {
      var absolute, sections;

      p = path._removeDuplicateSeps(p);
      absolute = p.charAt(0) === path.sep;
      sections = p.split(path.sep);
      if (sections.pop() === '' && sections.length > 0) {
        sections.pop();
      }
      if (sections.length > 1) {
        return sections.join(path.sep);
      } else if (absolute) {
        return path.sep;
      } else {
        return '.';
      }
    };

    path.basename = function(p, ext) {
      var lastPart, lastPartExt, sections;

      if (ext == null) {
        ext = "";
      }
      if (p === '') {
        return p;
      }
      p = path.normalize(p);
      sections = p.split(path.sep);
      lastPart = sections[sections.length - 1];
      if (lastPart === '' && sections.length > 1) {
        return sections[sections.length - 2];
      }
      if (ext.length > 0) {
        lastPartExt = lastPart.substr(lastPart.length - ext.length);
        if (lastPartExt === ext) {
          return lastPart.substr(0, lastPart.length - ext.length);
        }
      }
      return lastPart;
    };

    path.extname = function(p) {
      var i, sections;

      p = path.normalize(p);
      sections = p.split(path.sep);
      p = sections.pop();
      if (p === '' && sections.length > 0) {
        p = sections.pop();
      }
      if (p === '..') {
        return '';
      }
      i = p.lastIndexOf('.');
      if (i === -1 || i === 0) {
        return '';
      }
      return p.substr(i);
    };

    path.isAbsolute = function(p) {
      return p.length > 0 && p.charAt(0) === path.sep;
    };

    path._makeLong = function(p) {
      return p;
    };

    path.sep = '/';

    path._replaceRegex = new RegExp("//+", 'g');

    path._removeDuplicateSeps = function(p) {
      p = p.replace(this._replaceRegex, this.sep);
      return p;
    };

    path.delimiter = ':';

    return path;

  }).call(this);

}).call(this);
