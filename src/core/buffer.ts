// Generated by CoffeeScript 1.6.2
(function() {
  var makeArrayAccessors;

  if (Object.prototype.__defineGetter__ && !Object.defineProperty) {
    Object.defineProperty = function(obj, prop, desc) {
      if (desc.hasOwnProperty('get')) {
        obj.__defineGetter__(prop, desc.get);
      }
      if (desc.hasOwnProperty('set')) {
        return obj.__defineSetter__(prop, desc.set);
      }
    };
  }

  makeArrayAccessors = function(obj) {
    var i, makeArrayAccessor, _i, _ref;

    if (!Object.defineProperty) {
      return;
    }
    makeArrayAccessor = function(index) {
      return Object.defineProperty(obj, index, {
        'get': function() {
          return obj.get(index);
        },
        'set': function(v) {
          return obj.set(index, v);
        },
        enumerable: true,
        configurable: false
      });
    };
    for (i = _i = 0, _ref = obj.length; _i < _ref; i = _i += 1) {
      makeArrayAccessor(i);
    }
  };

  BrowserFS.node.Buffer = (function() {
    Buffer.isEncoding = function(enc) {
      var e;

      try {
        BrowserFS.StringUtil.FindUtil(enc);
      } catch (_error) {
        e = _error;
        return false;
      }
      return true;
    };

    Buffer.isBuffer = function(obj) {
      return obj instanceof BrowserFS.node.Buffer;
    };

    Buffer.byteLength = function(str, encoding) {
      var strUtil;

      if (encoding == null) {
        encoding = 'utf8';
      }
      strUtil = BrowserFS.StringUtil.FindUtil(encoding);
      return strUtil.byteLength(str);
    };

    Buffer.concat = function(list, totalLength) {
      var buf, curPos, item, _i, _j, _len, _len1;

      if (list.length === 0 || totalLength === 0) {
        return new BrowserFS.node.Buffer(0);
      } else if (list.length === 1) {
        return list[0];
      } else {
        if (totalLength == null) {
          totalLength = 0;
          for (_i = 0, _len = list.length; _i < _len; _i++) {
            item = list[_i];
            totalLength += item.length;
          }
        }
        buf = new BrowserFS.node.Buffer(totalLength);
        curPos = 0;
        for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
          item = list[_j];
          curPos += item.copy(buf, curPos);
        }
        return buf;
      }
    };

    function Buffer(arg1, arg2) {
      var datum, i, rv, _i, _j, _len, _ref;

      if (arg2 == null) {
        arg2 = 'utf8';
      }
      if (!(this instanceof BrowserFS.node.Buffer)) {
        return new BrowserFS.node.Buffer(arg1, arg2);
      }
      this._charsWritten = 0;
      if (typeof arg1 === 'number') {
        if (arg1 !== (arg1 >>> 0)) {
          throw new TypeError('Buffer size must be a uint32.');
        }
        this.length = arg1;
        this.buff = new DataView(new ArrayBuffer(this.length));
      } else if (arg1 instanceof DataView) {
        this.buff = arg1;
        this.length = arg1.byteLength;
      } else if (arg1 instanceof ArrayBuffer) {
        this.buff = new DataView(arg1);
        this.length = arg1.byteLength;
      } else if (arg1 instanceof BrowserFS.node.Buffer) {
        this.buff = new DataView(new ArrayBuffer(arg1.length));
        for (i = _i = 0, _ref = arg1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.buff.setUint8(i, arg1.get(i));
        }
        this.length = arg1.length;
      } else if (Array.isArray(arg1) || ((arg1[0] != null) && typeof arg1[0] === 'number')) {
        if ((DataView.isPolyfill != null) && Array.isArray(arg1)) {
          this.buff = new DataView(new ArrayBuffer(arg1));
          this.length = arg1.length;
        } else {
          this.buff = new DataView(new ArrayBuffer(arg1.length));
          for (i = _j = 0, _len = arg1.length; _j < _len; i = _j += 1) {
            datum = arg1[i];
            this.buff.setUint8(i, datum);
          }
          this.length = arg1.length;
        }
      } else if (typeof arg1 === 'string') {
        this.length = BrowserFS.node.Buffer.byteLength(arg1, arg2);
        this.buff = new DataView(new ArrayBuffer(this.length));
        rv = this.write(arg1, 0, this.length, arg2);
      } else {
        throw new Error("Invalid argument to Buffer constructor: " + arg1);
      }
    }

    Buffer.prototype.set = function(index, value) {
      return this.buff.setUint8(index, value);
    };

    Buffer.prototype.get = function(index) {
      return this.buff.getUint8(index);
    };

    Buffer.prototype.write = function(str, offset, length, encoding) {
      var strUtil;

      if (offset == null) {
        offset = 0;
      }
      if (length == null) {
        length = this.length;
      }
      if (encoding == null) {
        encoding = 'utf8';
      }
      if (typeof offset === 'string') {
        encoding = offset;
        offset = 0;
        length = this.length;
      } else if (typeof length === 'string') {
        encoding = length;
        length = this.length;
      }
      if (offset >= this.length) {
        return 0;
      }
      strUtil = BrowserFS.StringUtil.FindUtil(encoding);
      length = length + offset > this.length ? this.length - offset : length;
      return strUtil.str2byte(this, str, offset, length);
    };

    Buffer.prototype.toString = function(encoding, start, end) {
      var byteArr, i, len, strUtil, _i;

      if (encoding == null) {
        encoding = 'utf8';
      }
      if (start == null) {
        start = 0;
      }
      if (end == null) {
        end = this.length;
      }
      if (!(start <= end)) {
        throw new Error("Invalid start/end positions: " + start + " - " + end);
      }
      if (start === end) {
        return '';
      }
      if (end > this.length) {
        end = this.length;
      }
      strUtil = BrowserFS.StringUtil.FindUtil(encoding);
      len = end - start;
      byteArr = new Array(len);
      for (i = _i = 0; _i < len; i = _i += 1) {
        byteArr[i] = this.readUInt8(start + i);
      }
      return strUtil.byte2str(byteArr);
    };

    Buffer.prototype.toJSON = function() {
      var arr, i, _i, _ref;

      arr = new Array(this.length);
      for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 1) {
        arr[i] = this.buff.getUint8(i);
      }
      return {
        type: 'Buffer',
        data: arr
      };
    };

    Buffer.prototype.copy = function(target, targetStart, sourceStart, sourceEnd) {
      var bytesCopied, i, _i;

      if (targetStart == null) {
        targetStart = 0;
      }
      if (sourceStart == null) {
        sourceStart = 0;
      }
      if (sourceEnd == null) {
        sourceEnd = this.length;
      }
      targetStart = targetStart < 0 ? 0 : targetStart;
      sourceStart = sourceStart < 0 ? 0 : sourceStart;
      if (sourceEnd < sourceStart) {
        throw new RangeError('sourceEnd < sourceStart');
      }
      if (sourceEnd === sourceStart) {
        return 0;
      }
      if (targetStart >= target.length) {
        throw new RangeError('targetStart out of bounds');
      }
      if (sourceStart >= this.length) {
        throw new RangeError('sourceStart out of bounds');
      }
      if (sourceEnd > this.length) {
        throw new RangeError('sourceEnd out of bounds');
      }
      bytesCopied = Math.min(sourceEnd - sourceStart, target.length - targetStart, this.length - sourceStart);
      for (i = _i = 0; 0 <= bytesCopied ? _i < bytesCopied : _i > bytesCopied; i = 0 <= bytesCopied ? ++_i : --_i) {
        target.writeUInt8(this.readUInt8(sourceStart + i), targetStart + i);
      }
      return bytesCopied;
    };

    Buffer.prototype.slice = function(start, end) {
      if (start == null) {
        start = 0;
      }
      if (end == null) {
        end = this.length;
      }
      if (start < 0) {
        start += this.length;
        if (start < 0) {
          start = 0;
        }
      }
      if (end < 0) {
        end += this.length;
        if (end < 0) {
          end = 0;
        }
      }
      if (end > this.length) {
        end = this.length;
      }
      if (start > end) {
        start = end;
      }
      if (start < 0 || end < 0 || start >= this.length || end > this.length) {
        throw new Error("Invalid slice indices.");
      }
      return new BrowserFS.node.Buffer(new DataView(this.buff.buffer, this.buff.byteOffset + start, end - start));
    };

    Buffer.prototype.fill = function(value, offset, end) {
      var i, num32, remSt, val32, valType, _i, _j;

      if (offset == null) {
        offset = 0;
      }
      if (end == null) {
        end = this.length;
      }
      valType = typeof value;
      switch (valType) {
        case "string":
          value = value.charCodeAt(0) & 0xFF;
          break;
        case "number":
          break;
        default:
          throw new Error('Invalid argument to fill.');
      }
      val32 = value | (value << 8) | (value << 16) | (value << 24);
      num32 = Math.floor((end - offset) / 4);
      remSt = offset + num32 * 4;
      for (i = _i = 0; 0 <= num32 ? _i < num32 : _i > num32; i = 0 <= num32 ? ++_i : --_i) {
        this.writeUInt32LE(val32, offset + i * 4);
      }
      for (i = _j = remSt; remSt <= end ? _j < end : _j > end; i = remSt <= end ? ++_j : --_j) {
        this.writeUInt8(value, i);
      }
    };

    Buffer.prototype.readUInt8 = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getUint8(offset);
    };

    Buffer.prototype.readUInt16LE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getUint16(offset, true);
    };

    Buffer.prototype.readUInt16BE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getUint16(offset, false);
    };

    Buffer.prototype.readUInt32LE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getUint32(offset, true);
    };

    Buffer.prototype.readUInt32BE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getUint32(offset, false);
    };

    Buffer.prototype.readInt8 = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getInt8(offset);
    };

    Buffer.prototype.readInt16LE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getInt16(offset, true);
    };

    Buffer.prototype.readInt16BE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getInt16(offset, false);
    };

    Buffer.prototype.readInt32LE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getInt32(offset, true);
    };

    Buffer.prototype.readInt32BE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getInt32(offset, false);
    };

    Buffer.prototype.readFloatLE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getFloat32(offset, true);
    };

    Buffer.prototype.readFloatBE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getFloat32(offset, false);
    };

    Buffer.prototype.readDoubleLE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getFloat64(offset, true);
    };

    Buffer.prototype.readDoubleBE = function(offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.getFloat64(offset, false);
    };

    Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setUint8(offset, value);
    };

    Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setUint16(offset, value, true);
    };

    Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setUint16(offset, value, false);
    };

    Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setUint32(offset, value, true);
    };

    Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setUint32(offset, value, false);
    };

    Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setInt8(offset, value);
    };

    Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setInt16(offset, value, true);
    };

    Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setInt16(offset, value, false);
    };

    Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setInt32(offset, value, true);
    };

    Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setInt32(offset, value, false);
    };

    Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setFloat32(offset, value, true);
    };

    Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setFloat32(offset, value, false);
    };

    Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setFloat64(offset, value, true);
    };

    Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
      if (noAssert == null) {
        noAssert = false;
      }
      return this.buff.setFloat64(offset, value, false);
    };

    return Buffer;

  })();

}).call(this);
