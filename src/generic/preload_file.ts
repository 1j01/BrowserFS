// Generated by CoffeeScript 1.6.2
(function() {
  var _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BrowserFS.File.PreloadFile = (function(_super) {
    __extends(PreloadFile, _super);

    function PreloadFile(_fs, _path, _mode, _stat, contents) {
      this._fs = _fs;
      this._path = _path;
      this._mode = _mode;
      this._stat = _stat;
      this._pos = 0;
      if ((contents != null) && contents instanceof BrowserFS.node.Buffer) {
        this._buffer = contents;
      } else {
        this._buffer = new BrowserFS.node.Buffer(0);
      }
      if (this._stat.size !== this._buffer.length) {
        throw new Error("Invalid buffer: Buffer is " + this._buffer.length + " long, yet Stats object specifies that file is " + this._stat.size + " long.");
      }
    }

    PreloadFile.prototype.getPath = function() {
      return this._path;
    };

    PreloadFile.prototype.getPos = function() {
      if (this._mode.isAppendable()) {
        return this._stat.size;
      }
      return this._pos;
    };

    PreloadFile.prototype.advancePos = function(delta) {
      return this._pos += delta;
    };

    PreloadFile.prototype.setPos = function(newPos) {
      return this._pos = newPos;
    };

    PreloadFile.prototype.sync = function(cb) {
      var e;

      try {
        this.syncSync();
        return cb();
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    PreloadFile.prototype.syncSync = function() {
      throw new BrowserFS.ApiError(BrowserFS.ApiError.NOT_SUPPORTED);
    };

    PreloadFile.prototype.close = function(cb) {
      var e;

      try {
        this.closeSync();
        return cb();
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    PreloadFile.prototype.closeSync = function() {
      throw new BrowserFS.ApiError(BrowserFS.ApiError.NOT_SUPPORTED);
    };

    PreloadFile.prototype.stat = function(cb) {
      var e;

      try {
        return cb(null, this._stat.clone());
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    PreloadFile.prototype.statSync = function() {
      return this._stat.clone();
    };

    PreloadFile.prototype.truncate = function(len, cb) {
      var e;

      try {
        this.truncateSync(len);
        if (this._mode.isSynchronous() && !BrowserFS.node.fs.getRootFS().supportsSynch()) {
          return this.sync(cb);
        } else {
          return cb();
        }
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    PreloadFile.prototype.truncateSync = function(len) {
      var buf, newBuff;

      if (!this._mode.isWriteable()) {
        throw new BrowserFS.ApiError(BrowserFS.ApiError.PERMISSIONS_ERROR, 'File not opened with a writeable mode.');
      }
      this._stat.mtime = new Date();
      if (len > this._buffer.length) {
        buf = new Buffer(len - this._buffer.length);
        buf.fill(0);
        this.writeSync(buf, 0, buf.length, this._buffer.length);
        if (this._mode.isSynchronous() && BrowserFS.node.fs.getRootFS().supportsSynch()) {
          this.syncSync();
        }
        return;
      }
      this._stat.size = len;
      newBuff = new Buffer(len);
      this._buffer.copy(newBuff, 0, 0, len);
      this._buffer = newBuff;
      if (this._mode.isSynchronous() && BrowserFS.node.fs.getRootFS().supportsSynch()) {
        this.syncSync();
      }
    };

    PreloadFile.prototype.write = function(buffer, offset, length, position, cb) {
      var e;

      try {
        return cb(null, this.writeSync(buffer, offset, length, position), buffer);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    PreloadFile.prototype.writeSync = function(buffer, offset, length, position) {
      var endFp, len, newBuff;

      if (position == null) {
        position = this.getPos();
      }
      if (!this._mode.isWriteable()) {
        throw new BrowserFS.ApiError(BrowserFS.ApiError.PERMISSIONS_ERROR, 'File not opened with a writeable mode.');
      }
      endFp = position + length;
      if (endFp > this._stat.size) {
        this._stat.size = endFp;
        if (endFp > this._buffer.length) {
          newBuff = new Buffer(endFp);
          this._buffer.copy(newBuff);
          this._buffer = newBuff;
        }
      }
      len = buffer.copy(this._buffer, position, offset, offset + length);
      this._stat.mtime = new Date();
      if (this._mode.isSynchronous()) {
        this.syncSync();
        return len;
      }
      this.setPos(position + len);
      return len;
    };

    PreloadFile.prototype.read = function(buffer, offset, length, position, cb) {
      var e;

      try {
        return cb(null, this.readSync(buffer, offset, length, position), buffer);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    PreloadFile.prototype.readSync = function(buffer, offset, length, position) {
      var endRead, rv;

      if (!this._mode.isReadable()) {
        throw new BrowserFS.ApiError(BrowserFS.ApiError.PERMISSIONS_ERROR, 'File not opened with a readable mode.');
      }
      if (position == null) {
        position = this.getPos();
      }
      endRead = position + length;
      if (endRead > this._stat.size) {
        length = this._stat.size - position;
      }
      rv = this._buffer.copy(buffer, offset, position, position + length);
      this._stat.atime = new Date();
      this._pos = position + length;
      return rv;
    };

    PreloadFile.prototype.chmod = function(mode, cb) {
      var e;

      try {
        this.chmodSync(mode);
        return cb();
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    PreloadFile.prototype.chmodSync = function(mode) {
      if (!this._fs.supportsProps()) {
        throw new BrowserFS.ApiError(BrowserFS.ApiError.NOT_SUPPORTED);
      }
      this._stat.mode = mode;
      this.syncSync();
    };

    return PreloadFile;

  })(BrowserFS.File);

  BrowserFS.File.NoSyncFile = (function(_super) {
    __extends(NoSyncFile, _super);

    function NoSyncFile() {
      _ref = NoSyncFile.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    NoSyncFile.prototype.sync = function(cb) {
      return cb();
    };

    NoSyncFile.prototype.syncSync = function() {};

    NoSyncFile.prototype.close = function(cb) {
      return cb();
    };

    NoSyncFile.prototype.closeSync = function() {};

    return NoSyncFile;

  })(BrowserFS.File.PreloadFile);

}).call(this);
