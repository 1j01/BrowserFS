// Generated by CoffeeScript 1.6.2
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  document.write("<!-- IEBinaryToArray_ByteStr -->\r\n" + "<script type='text/vbscript'>\r\n" + "Function getIEByteArray(byteArray, out)\r\n" + "  Dim len, i\r\n" + "  len = LenB(byteArray)\r\n" + "  For i = 1 to len\r\n" + "    out.push(AscB(MidB(byteArray, i, 1)))\r\n" + "  Next\r\n" + "End Function\r\n" + "</script>\r\n");

  BrowserFS.FileSystem.XmlHttpRequest = (function(_super) {
    __extends(XmlHttpRequest, _super);

    function XmlHttpRequest(listing_url, prefix_url) {
      var file_data, listing;

      if (listing_url == null) {
        listing_url = 'index.json';
      }
      this.prefix_url = prefix_url != null ? prefix_url : '';
      file_data = this._request_file(listing_url, 'json');
      listing = JSON.parse(file_data);
      if (listing == null) {
        throw new Error("Unable to find listing at URL: " + listing_url);
      }
      this._index = BrowserFS.FileIndex.from_listing(listing);
    }

    XmlHttpRequest.prototype.empty = function() {
      var k, v, _ref, _results;

      _ref = this._index._index;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        if (v.file_data != null) {
          _results.push(v.file_data = void 0);
        }
      }
      return _results;
    };

    XmlHttpRequest.prototype._request_file_modern = function(path, data_type, cb) {
      var data, req;

      req = new XMLHttpRequest();
      req.open('GET', this.prefix_url + path, cb != null);
      req.responseType = data_type;
      data = null;
      req.onerror = function(e) {
        return console.error(req.statusText);
      };
      req.onload = function(e) {
        var _ref;

        if (!(req.readyState === 4 && req.status === 200)) {
          console.error(req.statusText);
        }
        if (data_type === 'arraybuffer') {
          data = new BrowserFS.node.Buffer((_ref = req.response) != null ? _ref : 0);
        } else {
          data = req.response;
        }
        return typeof cb === "function" ? cb(data) : void 0;
      };
      req.send();
      if ((data != null) && data !== 'NOT FOUND') {
        return data;
      }
    };

    XmlHttpRequest.prototype._request_file_size = function(path, cb) {
      var req;

      req = new XMLHttpRequest();
      req.open('HEAD', this.prefix_url + path);
      req.onreadystatechange = function(e) {
        if (req.readyState === 4) {
          if (req.status !== 200) {
            console.error(req.statusText);
          }
          return cb(req.getResponseHeader('Content-Length'));
        }
      };
      return req.send();
    };

    XmlHttpRequest.prototype._request_file_IE = function(path, data_type, cb) {
      var data, req,
        _this = this;

      req = new XMLHttpRequest();
      req.open('GET', this.prefix_url + path, cb != null);
      req.setRequestHeader("Accept-Charset", "x-user-defined");
      data = null;
      req.onreadystatechange = function(e) {
        var data_array;

        if (req.readyState === 4) {
          if (req.status === 200) {
            if (data_type === 'arraybuffer') {
              getIEByteArray(req.responseBody, data_array = []);
              data = new BrowserFS.node.Buffer(data_array);
            } else {
              data = req.responseText;
            }
            return typeof cb === "function" ? cb(data) : void 0;
          } else {
            return console.error("ReadyState: " + req.readyState + " Status: " + req.status);
          }
        }
      };
      req.send();
      if ((data != null) && data !== 'NOT FOUND') {
        return data;
      }
    };

    if (BrowserFS.isIE && !window.Blob) {
      XmlHttpRequest.prototype._request_file = XmlHttpRequest.prototype._request_file_IE;
    } else {
      XmlHttpRequest.prototype._request_file = XmlHttpRequest.prototype._request_file_modern;
    }

    XmlHttpRequest.prototype.getName = function() {
      return 'XmlHttpRequest';
    };

    XmlHttpRequest.isAvailable = function() {
      return typeof XMLHttpRequest !== "undefined" && XMLHttpRequest !== null;
    };

    XmlHttpRequest.prototype.diskSpace = function(path, cb) {
      return cb(0, 0);
    };

    XmlHttpRequest.prototype.isReadOnly = function() {
      return true;
    };

    XmlHttpRequest.prototype.supportsLinks = function() {
      return false;
    };

    XmlHttpRequest.prototype.supportsProps = function() {
      return false;
    };

    XmlHttpRequest.prototype.preloadFile = function(path, buffer) {
      var inode;

      inode = this._index.getInode(path);
      if (inode === null) {
        throw new BrowserFS.ApiError(BrowserFS.ApiError.NOT_FOUND, "" + path + " not found.");
      }
      inode.size = buffer.length;
      inode.file_data = new BrowserFS.File.NoSyncFile(this, path, BrowserFS.FileMode.getFileMode('r'), inode, buffer);
    };

    XmlHttpRequest.prototype.stat = function(path, isLstat, cb) {
      var inode, stats, _ref;

      inode = this._index.getInode(path);
      if (inode === null) {
        return cb(new BrowserFS.ApiError(BrowserFS.ApiError.NOT_FOUND, "" + path + " not found."));
      }
      if (inode.size < 0) {
        this._request_file_size(path, function(size) {
          inode.size = size;
          return cb(null, inode);
        });
      } else {
        stats = (_ref = typeof inode.getStats === "function" ? inode.getStats() : void 0) != null ? _ref : inode;
        cb(null, stats);
      }
    };

    XmlHttpRequest.prototype.open = function(path, flags, mode, cb) {
      var inode,
        _this = this;

      inode = this._index.getInode(path);
      if (inode === null) {
        return cb(new BrowserFS.ApiError(BrowserFS.ApiError.NOT_FOUND, "" + path + " is not in the FileIndex."));
      }
      if (inode.isDirectory()) {
        return cb(new BrowserFS.ApiError(BrowserFS.ApiError.NOT_FOUND, "" + path + " is a directory."));
      }
      switch (flags.pathExistsAction()) {
        case BrowserFS.FileMode.THROW_EXCEPTION:
        case BrowserFS.FileMode.TRUNCATE_FILE:
          return cb(new BrowserFS.ApiError(BrowserFS.ApiError.NOT_FOUND, "" + path + " already exists."));
        case BrowserFS.FileMode.NOP:
          if (inode.file_data != null) {
            return cb(null, inode.file_data);
          }
          this._request_file(path, 'arraybuffer', function(buffer) {
            inode.size = buffer.length;
            inode.file_data = new BrowserFS.File.NoSyncFile(_this, path, flags, inode, buffer);
            return cb(null, inode.file_data);
          });
          break;
        default:
          return cb(new BrowserFS.ApiError(BrowserFS.ApiError.INVALID_PARAM, 'Invalid FileMode object.'));
      }
    };

    XmlHttpRequest.prototype.readdir = function(path, cb) {
      var inode;

      inode = this._index.getInode(path);
      if (inode === null) {
        return cb(new BrowserFS.ApiError(BrowserFS.ApiError.NOT_FOUND, "" + path + " not found."));
      } else if (inode.isFile()) {
        return cb(new BrowserFS.ApiError(BrowserFS.ApiError.NOT_FOUND, "" + path + " is a file, not a directory."));
      }
      return cb(null, inode.getListing());
    };

    return XmlHttpRequest;

  })(BrowserFS.FileSystem);

}).call(this);
