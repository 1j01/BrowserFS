import file_system = require('../core/file_system');
import file_index = require('../generic/file_index');
import buffer = require('../core/buffer');
import api_error = require('../core/api_error');
import file_flag = require('../core/file_flag');
import util = require('../core/util');
import file = require('../core/file');
import node_fs_stats = require('../core/node_fs_stats');
import preload_file = require('../generic/preload_file');
import browserfs = require('../core/browserfs');

var Buffer = buffer.Buffer;
var ApiError = api_error.ApiError;
var ErrorType = api_error.ErrorType;
var FileFlag = file_flag.FileFlag;
var ActionType = file_flag.ActionType;

/**
 * IE9 and below only: Injects a VBScript function that converts the
 * 'responseBody' attribute of an XMLHttpRequest into a bytestring.
 * From ExtJS: http://docs-origin.sencha.com/extjs/4.1.3/source/Connection.html
 *
 * NOTE: We *must* perform this check, as document.write causes a full page
 *       reload in Firefox, and does something bizarre in Chrome/Safari that
 *       causes all of our unit tests to fail.
 */
if (util.isIE) {
  document.write("<!-- IEBinaryToArray_ByteStr -->\r\n" +
    "<script type='text/vbscript'>\r\n" +
    "Function getIEByteArray(byteArray, out)\r\n" +
    "  Dim len, i\r\n" + "  len = LenB(byteArray)\r\n" +
    "  For i = 1 to len\r\n" +
    "    out.push(AscB(MidB(byteArray, i, 1)))\r\n" +
    "  Next\r\n" +
    "End Function\r\n" +
    "</script>\r\n");
}

declare var getIEByteArray: (vbarr: any, arr: number[]) => void;

/**
 * A simple filesystem backed by XmlHttpRequests.
 *
 * An abstract class; subclasses implement variants for browsers with differing
 * behavior.
 */
export class XmlHttpRequestAbstract extends file_system.FileSystem {
  private _index: file_index.FileIndex;
  public prefix_url: string;
  /**
   * Constructs the file system.
   * @param [String] listing_url The path to the JSON file index generated by
   *   tools/XHRIndexer.coffee. This can be relative to the current webpage URL
   *   or absolutely specified.
   * @param [String] prefix_url The url prefix to use for all web-server requests.
   */
  constructor(listing_url: string, prefix_url: string) {
    super();
    if (listing_url == null) {
      listing_url = 'index.json';
    }
    this.prefix_url = prefix_url != null ? prefix_url : '';
    var listingString = this._request_file(listing_url, 'json');
    var listing = JSON.parse(listingString);
    if (listing == null) {
      throw new Error("Unable to find listing at URL: " + listing_url);
    }
    this._index = file_index.FileIndex.from_listing(listing);
  }

  public empty(): void {
    var idx = this._index._index;
    for (var k in idx) {
      var v = <node_fs_stats.Stats> idx[k];
      if (v.file_data != null) {
        v.file_data = null;
      }
    }
  }

  /**
   * Only requests the HEAD content, for the file size.
   */
  public _request_file_size(path: string, cb: (size: number) => void): void {
    var req = new XMLHttpRequest();
    req.open('HEAD', this.prefix_url + path);
    req.onreadystatechange = function(e) {
      if (req.readyState === 4) {
        if (req.status !== 200) {
          console.error(req.statusText);
        }
        try {
          cb(parseInt(req.getResponseHeader('Content-Length'), 10));
        } catch(e) {
          // In the event that the header isn't present or there is an error...
          cb(-1);
        }
      }
    };
    req.send();
  }

  /**
   * Assumes that path is in @_index.
   * TODO(jvilk): Separate into async / sync methods.
   */
  public _request_file(path: string, data_type: string, cb?: (data: any) => void): any {
    throw new ApiError(ErrorType.NOT_SUPPORTED, 'XmlHttpRequestAbstract is an abstract class.');
  }

  public getName(): string {
    return 'XmlHttpRequest';
  }

  public static isAvailable(): boolean {
    // @todo Older browsers use a different name for XHR, iirc.
    return typeof XMLHttpRequest !== "undefined" && XMLHttpRequest !== null;
  }

  public diskSpace(path: string, cb: (total: number, free: number) => void): void {
    // Read-only file system. We could calculate the total space, but that's not
    // important right now.
    cb(0, 0);
  }

  public isReadOnly(): boolean {
    return true;
  }

  public supportsLinks(): boolean {
    return false;
  }

  public supportsProps(): boolean {
    return false;
  }

  public supportsSynch(): boolean {
    return false;
  }

  /**
   * Special XHR function: Preload the given file into the index.
   * @param [String] path
   * @param [BrowserFS.Buffer] buffer
   */
  public preloadFile(path: string, buffer: buffer.Buffer): void {
    var inode = <node_fs_stats.Stats> this._index.getInode(path);
    if (inode === null) {
      throw new ApiError(ErrorType.NOT_FOUND, "" + path + " not found.");
    }
    inode.size = buffer.length;
    inode.file_data = new preload_file.NoSyncFile(this, path, FileFlag.getFileFlag('r'), inode, buffer);
  }

  public stat(path: string, isLstat: boolean, cb: (e: api_error.ApiError, stat?: node_fs_stats.Stats) => void): void {
    var inode = this._index.getInode(path);
    if (inode === null) {
      return cb(new ApiError(ErrorType.NOT_FOUND, "" + path + " not found."));
    }
    var stats: node_fs_stats.Stats;
    if (inode.isFile()) {
      stats = <node_fs_stats.Stats> inode;
      // At this point, a non-opened file will still have default stats from the listing.
      if (stats.size < 0) {
        this._request_file_size(path, function(size) {
          stats.size = size;
          cb(null, stats);
        });
      } else {
        cb(null, stats);
      }
    } else {
      stats = (<file_index.DirInode> inode).getStats();
      cb(null, stats);
    }
  }

  public open(path: string, flags: file_flag.FileFlag, mode: number, cb: (e: api_error.ApiError, file?: file.File) => void): void {
    var _this = this;
    // Check if the path exists, and is a file.
    var inode = <node_fs_stats.Stats> this._index.getInode(path);
    if (inode === null) {
      return cb(new ApiError(ErrorType.NOT_FOUND, "" + path + " is not in the FileIndex."));
    }
    if (inode.isDirectory()) {
      return cb(new ApiError(ErrorType.NOT_FOUND, "" + path + " is a directory."));
    }
    switch (flags.pathExistsAction()) {
      case ActionType.THROW_EXCEPTION:
      case ActionType.TRUNCATE_FILE:
        return cb(new ApiError(ErrorType.NOT_FOUND, "" + path + " already exists."));
      case ActionType.NOP:
        // Use existing file contents.
        // XXX: Uh, this maintains the previously-used flag.
        if (inode.file_data != null) {
          return cb(null, inode.file_data);
        }
        // @todo be lazier about actually requesting the file
        this._request_file(path, 'arraybuffer', function(buffer) {
          // we don't initially have file sizes
          inode.size = buffer.length;
          inode.file_data = new preload_file.NoSyncFile(_this, path, flags, inode, buffer);
          return cb(null, inode.file_data);
        });
        break;
      default:
        return cb(new ApiError(ErrorType.INVALID_PARAM, 'Invalid FileMode object.'));
    }
  }

  public readdir(path: string, cb: (e: api_error.ApiError, listing?: string[]) => void): void {
    // Check if it exists.
    var inode = this._index.getInode(path);
    if (inode === null) {
      return cb(new ApiError(ErrorType.NOT_FOUND, "" + path + " not found."));
    } else if (inode.isFile()) {
      return cb(new ApiError(ErrorType.NOT_FOUND, "" + path + " is a file, not a directory."));
    }
    return cb(null, (<file_index.DirInode> inode).getListing());
  }
}

/**
 * A version of XHRFS tailored for IE, which does not have Typed Array
 * support *OR* a way to download binary files in 100% JavaScript. :(
 */
export class XmlHttpRequestIE extends XmlHttpRequestAbstract {
  constructor(listing_url: string, prefix_url: string) {
    super(listing_url, prefix_url);
  }

  public _request_file(p: string, data_type: string, cb?: (data: any) => void): any {
    var _this = this;
    var req = new XMLHttpRequest();
    req.open('GET', this.prefix_url + p, cb != null);
    req.setRequestHeader("Accept-Charset", "x-user-defined");
    var data = null;
    req.onreadystatechange = function(e) {
      var data_array;
      if (req.readyState === 4) {
        if (req.status === 200) {
          if (data_type === 'arraybuffer') {
            // Call our VBScript method, which mutates data_array.
            getIEByteArray(req.responseBody, data_array = []);
            data = new Buffer(data_array);
          } else {
            data = req.responseText;
          }
          return typeof cb === "function" ? cb(data) : void 0;
        } else {
          console.error("ReadyState: " + req.readyState + " Status: " + req.status);
        }
      }
    };
    req.send();
    if ((data != null) && data !== 'NOT FOUND') {
      return data;
    }
  }
}
browserfs.registerFileSystem('XmlHttpRequestIE', XmlHttpRequestIE);

/**
 * A version of XHRFS tailored to modern browsers with typed array support.
 */
export class XmlHttpRequestModern extends XmlHttpRequestAbstract {
  constructor(listing_url: string, prefix_url: string) {
    super(listing_url, prefix_url);
  }

  public _request_file(p: string, data_type: string, cb?: (data: any) => void): any {
    var req = new XMLHttpRequest();
    req.open('GET', this.prefix_url + p, cb != null);
    // XXX: FF and Chrome refuse to set responseType on synchronous XHRs.
    if (cb != null) {
      req.responseType = data_type;
    }
    var data = null;
    req.onerror = function(e) {
      console.error(req.statusText);
    };
    req.onload = function(e) {
      if (!(req.readyState === 4 && req.status === 200)) {
        console.error(req.statusText);
      }
      if (data_type === 'arraybuffer') {
        // XXX: WebKit-based browsers return *null* when XHRing an empty file.
        data = new Buffer(req.response ? req.response : 0);
      } else {
        data = req.response;
      }
      return typeof cb === "function" ? cb(data) : void 0;
    };
    req.send();
    if ((data != null) && data !== 'NOT FOUND') {
      return data;
    }
  }
}
browserfs.registerFileSystem('XmlHttpRequestModern', XmlHttpRequestModern);

// Export the variant that works best in the current browser as the true XHRFS.
export var XmlHttpRequest = (util.isIE && typeof window['Blob'] === 'undefined') ? XmlHttpRequestIE : XmlHttpRequestModern;
browserfs.registerFileSystem('XmlHttpRequest', XmlHttpRequest);
