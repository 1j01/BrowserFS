# A simple filesystem backed by XmlHttpRequests.
class BrowserFS.FileSystem.XmlHttpRequest extends BrowserFS.IndexedFileSystem
  # Constructs the file system.
  # @param [String] listing_url The path to the JSON file index generated by
  #   tools/XHRIndexer.coffee. This can be relative to the current webpage URL
  #   or absolutely specified.
  constructor: (listing_url='index.json') ->
    listing = JSON.parse @_request_file(listing_url, 'json')
    unless listing?
      throw new Error "Unable to find listing at URL: #{listing_url}"
    @_index = BrowserFS.FileIndex.from_listing listing

  _request_file: (path, data_type, cb) ->
    # Ensure the file is in the index.
    return null if @_index?.getInode(path) == null
    req = new XMLHttpRequest()
    req.open 'GET', path, cb?
    req.responseType = data_type
    data = null
    req.onerror = (e) -> console.error req.statusText
    req.onload = (e) ->
      unless req.readyState is 4 and req.status is 200
        console.error req.statusText
      return cb(req.response) if cb?
      data = req.response
    req.send()
    if data? and data != 'NOT FOUND'
      return data

  # Returns the name of the file system.
  # @return [String]
  getName: -> 'XmlHttpRequest'
  # Does the browser support XmlHttpRequest?
  # @return [Boolean]
  isAvailable: ->
    # Note: Older browsers use a different name for XHR, iirc.
    XMLHttpRequest?
  # Passes the size and taken space in bytes to the callback. Size will always
  # be equal to taken space, since this is a read-only file system.
  # @param [String] path Unused in the implementation.
  # @param [Function(Number, Number)] cb
  diskSpace: (path, cb) ->
    cb 0, 0
  # Returns true; this filesystem is read-only.
  # @return [Boolean]
  isReadOnly: -> true
  # Returns false; this filesystem does not support symlinks.
  # @return [Boolean]
  supportsLinks: -> false
  # Returns false; this filesystem does not support properties.
  # @return [Boolean]
  supportsProps: -> false

  # File operations

  open: (path, flags, mode, cb) ->
    # Check if the path exists, and is a file.
    inode = @_index.getInode path
    if inode isnt null
      unless inode.isFile()
        return cb new BrowserFS.ApiError BrowserFS.ApiError.NOT_FOUND, "#{path} is a directory."
      switch flags.pathExistsAction()
        when BrowserFS.FileMode.THROW_EXCEPTION, BrowserFS.FileMode.TRUNCATE_FILE
          return cb new BrowserFS.ApiError BrowserFS.ApiError.INVALID_PARAM, "#{path} already exists."
        when BrowserFS.FileMode.NOP
          # Use existing file contents.
          @_request_file path, 'arraybuffer', (buffer) =>
            file = new BrowserFS.File.NoSyncFile @, path, flags, inode, buffer
            return cb null, file
        else
          return cb new BrowserFS.ApiError BrowserFS.ApiError.INVALID_PARAM, 'Invalid FileMode object.'
    else
      switch flags.pathNotExistsAction()
        when BrowserFS.FileMode.THROW_EXCEPTION, BrowserFS.FileMode.CREATE_FILE
          return cb new BrowserFS.ApiError BrowserFS.ApiError.INVALID_PARAM, "#{path} doesn't exist."
        else
          return cb new BrowserFS.ApiError BrowserFS.ApiError.INVALID_PARAM, 'Invalid FileMode object.'
