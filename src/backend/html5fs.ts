// Generated by CoffeeScript 1.6.2
(function() {
  var _getFS, _ref, _toArray,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _getFS = function() {
    return window.webkitRequestFileSystem || window.requestFileSystem || null;
  };

  _toArray = function(list) {
    return Array.prototype.slice.call(list || [], 0);
  };

  BrowserFS.File.HTML5FSFile = (function(_super) {
    __extends(HTML5FSFile, _super);

    function HTML5FSFile() {
      _ref = HTML5FSFile.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    HTML5FSFile.prototype.sync = function(cb) {
      var error, opts, self, success;

      self = this;
      opts = {
        create: false
      };
      success = function(entry) {
        return entry.createWriter(function(writer) {
          var blob, length;

          blob = new Blob([self._buffer.buff]);
          length = blob.size;
          writer.onwriteend = function(event) {
            writer.onwriteend = null;
            writer.truncate(length);
            return typeof cb === "function" ? cb() : void 0;
          };
          writer.onerror = function(err) {
            return self._fs._sendError(cb, 'Write failed');
          };
          return writer.write(blob);
        });
      };
      error = function(err) {
        return self._fs._sendError(cb, err);
      };
      return this._fs.fs.root.getFile(this._path, opts, success, error);
    };

    HTML5FSFile.prototype.close = function(cb) {
      return this.sync(cb);
    };

    return HTML5FSFile;

  })(BrowserFS.File.PreloadFile);

  BrowserFS.FileSystem.HTML5FS = (function(_super) {
    __extends(HTML5FS, _super);

    function HTML5FS(size, type) {
      var kb, mb;

      this.size = size != null ? size : 5;
      this.type = type != null ? type : window.PERSISTENT;
      kb = 1024;
      mb = kb * kb;
      this.size *= mb;
    }

    HTML5FS.prototype.getName = function() {
      return 'HTML5 FileSystem';
    };

    HTML5FS.isAvailable = function() {
      return _getFS() != null;
    };

    HTML5FS.prototype.isReadOnly = function() {
      return false;
    };

    HTML5FS.prototype.supportsSymlinks = function() {
      return false;
    };

    HTML5FS.prototype.supportsProps = function() {
      return false;
    };

    HTML5FS.prototype.supportsSynch = function() {
      return false;
    };

    HTML5FS.prototype._humanise = function(err) {
      switch (err.code) {
        case DOMError.QUOTA_EXCEEDED_ERR:
          return 'Filesystem full. Please delete some files to free up space.';
        case DOMError.NOT_FOUND_ERR:
          return 'File does not exist.';
        case DOMError.SECURITY_ERR:
          return 'Insecure file access.';
        default:
          return "Unknown Error: " + err.name;
      }
    };

    HTML5FS.prototype.allocate = function(cb) {
      var error, getter, self, success;

      self = this;
      success = function(fs) {
        self.fs = fs;
        return typeof cb === "function" ? cb() : void 0;
      };
      error = function(err) {
        var msg;

        msg = self._humanise(err);
        console.error("Failed to create FS");
        console.error(msg);
        return typeof cb === "function" ? cb(err) : void 0;
      };
      getter = _getFS();
      if (this.type === window.PERSISTENT) {
        return window.webkitStorageInfo.requestQuota(this.type, this.size, function(granted) {
          return getter(this.type, granted, success, error);
        });
      } else {
        return getter(this.type, this.size, success, error);
      }
    };

    HTML5FS.prototype.empty = function(main_cb) {
      var self;

      self = this;
      return self._readdir('/', function(err, entries) {
        var deleteEntry, finished;

        if (err) {
          console.error('Failed to empty FS');
          return main_cb(err);
        } else {
          finished = function(err) {
            if (err) {
              console.error("Failed to empty FS");
              return main_cb(err);
            } else {
              return main_cb();
            }
          };
          deleteEntry = function(entry, cb) {
            var succ;

            succ = function() {
              return cb();
            };
            err = function() {
              return cb("Failed to remove " + entry.fullPath);
            };
            if (entry.isFile) {
              return entry.remove(succ, err);
            } else {
              return entry.removeRecursively(succ, err);
            }
          };
          return async.each(entries, deleteEntry, finished);
        }
      });
    };

    HTML5FS.prototype.rename = function(oldPath, newPath, cb) {
      var error, self, success;

      self = this;
      success = function(file) {
        file.moveTo(oldPath, newPath);
        return cb();
      };
      error = function(err) {
        return self._sendError(cb, "Could not rename " + oldPath + " to " + newPath);
      };
      return this.fs.root.getFile(oldPath, {}, success, error);
    };

    HTML5FS.prototype.stat = function(path, isLstat, cb) {
      var failedToLoad, failedToLoadAsFile, loadAsDir, loadAsFile, opts, self;

      self = this;
      opts = {
        create: false
      };
      loadAsFile = function(entry) {
        var fileFromEntry;

        fileFromEntry = function(file) {
          var stat;

          stat = new BrowserFS.node.fs.Stats(BrowserFS.node.fs.Stats.FILE, file.size);
          return cb(null, stat);
        };
        return entry.file(fileFromEntry, failedToLoad);
      };
      loadAsDir = function(dir) {
        var size, stat;

        size = 4096;
        stat = new BrowserFS.node.fs.Stats(BrowserFS.node.fs.Stats.DIRECTORY, size);
        return cb(null, stat);
      };
      failedToLoad = function(err) {
        return self._sendError(cb, "Could not stat " + path);
      };
      failedToLoadAsFile = function() {
        return self.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);
      };
      return this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);
    };

    HTML5FS.prototype.open = function(path, flags, mode, cb) {
      var error, opts, self, success;

      self = this;
      opts = {
        create: flags.pathNotExistsAction() === BrowserFS.FileMode.CREATE_FILE,
        exclusive: flags.isExclusive()
      };
      error = function(err) {
        return self._sendError(cb, "Could not open " + path);
      };
      success = function(entry) {
        var success2;

        success2 = function(file) {
          var reader;

          reader = new FileReader();
          reader.onloadend = function(event) {
            var bfs_file;

            bfs_file = self._makeFile(path, flags, file, event.target.result);
            return cb(null, bfs_file);
          };
          reader.onerror = error;
          return reader.readAsArrayBuffer(file);
        };
        return entry.file(success2, error);
      };
      return this.fs.root.getFile(path, opts, success, error);
    };

    HTML5FS.prototype._sendError = function(cb, err) {
      var msg;

      msg = typeof err === 'string' ? err : this._humanise(err);
      return cb(new BrowserFS.ApiError(BrowserFS.ApiError.INVALID_PARAM, msg));
    };

    HTML5FS.prototype._statType = function(stat) {
      return BrowserFS.node.fs.Stats[stat.isFile ? 'FILE' : 'DIRECTORY'];
    };

    HTML5FS.prototype._makeFile = function(path, mode, stat, data) {
      var buffer, type;

      type = this._statType(stat);
      stat = new BrowserFS.node.fs.Stats(type, stat.size);
      data || (data = '');
      buffer = new BrowserFS.node.Buffer(data);
      return new BrowserFS.File.HTML5FSFile(this, path, mode, stat, buffer);
    };

    HTML5FS.prototype._remove = function(path, cb, isFile) {
      var error, method, opts, self, success;

      self = this;
      method = "get" + (isFile ? 'File' : 'Directory');
      success = function(entry) {
        var err, succ;

        succ = function() {
          return cb();
        };
        err = function() {
          return self._sendError(cb, "Failed to remove " + path);
        };
        return entry.remove(succ, err);
      };
      error = function(err) {
        return self._sendError(cb, "Failed to remove " + path);
      };
      opts = {
        create: false
      };
      return this.fs.root[method](path, opts, success, error);
    };

    HTML5FS.prototype.unlink = function(path, cb) {
      return this._remove(path, cb, true);
    };

    HTML5FS.prototype.rmdir = function(path, cb) {
      return this._remove(path, cb, false);
    };

    HTML5FS.prototype.mkdir = function(path, mode, cb) {
      var error, opts, self, success;

      self = this;
      opts = {
        create: true,
        exclusive: true
      };
      success = function(dir) {
        return cb();
      };
      error = function(err) {
        return self._sendError(cb, "Could not create directory: " + path);
      };
      return this.fs.root.getDirectory(path, opts, success, error);
    };

    HTML5FS.prototype._readdir = function(path, cb) {
      var entries, error, readEntries, reader, self;

      self = this;
      reader = this.fs.root.createReader();
      entries = [];
      error = function(err) {
        return self._sendError(cb, err);
      };
      readEntries = function() {
        return reader.readEntries((function(results) {
          if (results.length) {
            entries = entries.concat(_toArray(results));
            return readEntries();
          } else {
            return cb(null, entries);
          }
        }), error);
      };
      return readEntries();
    };

    HTML5FS.prototype.readdir = function(path, cb) {
      return this._readdir(path, function(entries) {
        var entry;

        return cb((function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = entries.length; _i < _len; _i++) {
            entry = entries[_i];
            _results.push(entry.name);
          }
          return _results;
        })());
      });
    };

    return HTML5FS;

  })(BrowserFS.FileSystem);

}).call(this);
