import file = require('./file');
import api_error = require('./api_error');
import file_system = require('./file_system');
import node_fs_stats = require('./node_fs_stats');
declare class fs {
    private static root;
    static _initialize(rootFS: file_system.FileSystem): file_system.FileSystem;
    static _toUnixTimestamp(time: Date): number;
    static _toUnixTimestamp(time: number): number;
    static getRootFS(): file_system.FileSystem;
    static rename(oldPath: string, newPath: string, cb?: (err?: api_error.ApiError) => void): void;
    static renameSync(oldPath: string, newPath: string): void;
    static exists(path: string, cb?: (exists: boolean) => void): void;
    static existsSync(path: string): boolean;
    static stat(path: string, cb?: (err: api_error.ApiError, stats?: node_fs_stats.Stats) => any): void;
    static statSync(path: string): node_fs_stats.Stats;
    static lstat(path: string, cb?: (err: api_error.ApiError, stats?: node_fs_stats.Stats) => any): void;
    static lstatSync(path: string): node_fs_stats.Stats;
    static truncate(path: string, cb?: Function): void;
    static truncate(path: string, len: number, cb?: Function): void;
    static truncateSync(path: string, len?: number): void;
    static unlink(path: string, cb?: Function): void;
    static unlinkSync(path: string): void;
    static open(path: string, flag: string, cb?: (err: api_error.ApiError, fd?: file.File) => any): void;
    static open(path: string, flag: string, mode: string, cb?: (err: api_error.ApiError, fd?: file.File) => any): void;
    static open(path: string, flag: string, mode: number, cb?: (err: api_error.ApiError, fd?: file.File) => any): void;
    static openSync(path: string, flag: string, mode?: string): file.File;
    static openSync(path: string, flag: string, mode?: number): file.File;
    static readFile(filename: string, cb?: (err: api_error.ApiError, data?: any) => void): void;
    static readFile(filename: string, options: {
        [opt: string]: any;
    }, cb?: (err: api_error.ApiError, data?: any) => void): void;
    static readFile(filename: string, encoding: string, cb?: (err: api_error.ApiError, data?: any) => void): void;
    static readFileSync(filename: string, encoding?: string): NodeBuffer;
    static readFileSync(filename: string, options?: {
        encoding?: string;
        flag?: string;
    }): NodeBuffer;
    static writeFile(filename: string, data: any, cb?: (err?: api_error.ApiError) => void): void;
    static writeFile(filename: string, data: any, encoding?: string, cb?: (err?: api_error.ApiError) => void): void;
    static writeFile(filename: string, data: any, options?: Object, cb?: (err?: api_error.ApiError) => void): void;
    static writeFileSync(filename: string, data: any, options?: Object): void;
    static writeFileSync(filename: string, data: any, encoding?: string): void;
    static appendFile(filename: string, data: any, cb?: (err: api_error.ApiError) => void): void;
    static appendFile(filename: string, data: any, options?: Object, cb?: (err: api_error.ApiError) => void): void;
    static appendFile(filename: string, data: any, encoding?: string, cb?: (err: api_error.ApiError) => void): void;
    static appendFileSync(filename: string, data: any, options?: Object): void;
    static appendFileSync(filename: string, data: any, encoding?: string): void;
    static fstat(fd: file.File, cb?: (err: api_error.ApiError, stats?: node_fs_stats.Stats) => any): void;
    static fstatSync(fd: file.File): node_fs_stats.Stats;
    static close(fd: file.File, cb?: Function): void;
    static closeSync(fd: file.File): void;
    static ftruncate(fd: file.File, cb?: Function): void;
    static ftruncate(fd: file.File, len?: number, cb?: Function): void;
    static ftruncateSync(fd: file.File, len?: number): void;
    static fsync(fd: file.File, cb?: Function): void;
    static fsyncSync(fd: file.File): void;
    static fdatasync(fd: file.File, cb?: Function): void;
    static fdatasyncSync(fd: file.File): void;
    static write(fd: file.File, buffer: NodeBuffer, offset: number, length: number, cb?: (err: api_error.ApiError, written?: number, buffer?: NodeBuffer) => any): void;
    static write(fd: file.File, buffer: NodeBuffer, offset: number, length: number, position?: number, cb?: (err: api_error.ApiError, written?: number, buffer?: NodeBuffer) => any): void;
    static write(fd: file.File, data: string, cb?: (err: api_error.ApiError, written?: number, buffer?: NodeBuffer) => any): void;
    static write(fd: file.File, data: string, position: number, cb?: (err: api_error.ApiError, written?: number, buffer?: NodeBuffer) => any): void;
    static write(fd: file.File, data: string, position: number, encoding: string, cb?: (err: api_error.ApiError, written?: number, buffer?: NodeBuffer) => any): void;
    static writeSync(fd: file.File, buffer: NodeBuffer, offset: number, length: number, position?: number): number;
    static writeSync(fd: file.File, data: string, position?: number, encoding?: string): number;
    static read(fd: file.File, length: number, position: number, encoding: string, cb?: (err: api_error.ApiError, data?: string, bytesRead?: number) => void): void;
    static read(fd: file.File, buffer: NodeBuffer, offset: number, length: number, position: number, cb?: (err: api_error.ApiError, bytesRead?: number, buffer?: NodeBuffer) => void): void;
    static readSync(fd: file.File, length: number, position: number, encoding: string): string;
    static readSync(fd: file.File, buffer: NodeBuffer, offset: number, length: number, position: number): number;
    static fchown(fd: file.File, uid: number, gid: number, callback?: Function): void;
    static fchownSync(fd: file.File, uid: number, gid: number): void;
    static fchmod(fd: file.File, mode: string, cb?: Function): void;
    static fchmod(fd: file.File, mode: number, cb?: Function): void;
    static fchmodSync(fd: file.File, mode: string): void;
    static fchmodSync(fd: file.File, mode: number): void;
    static futimes(fd: file.File, atime: number, mtime: number, cb: Function): void;
    static futimes(fd: file.File, atime: Date, mtime: Date, cb: Function): void;
    static futimesSync(fd: file.File, atime: number, mtime: number): void;
    static futimesSync(fd: file.File, atime: Date, mtime: Date): void;
    static rmdir(path: string, cb?: Function): void;
    static rmdirSync(path: string): void;
    static mkdir(path: string, mode?: any, cb?: Function): void;
    static mkdirSync(path: string, mode?: string): void;
    static mkdirSync(path: string, mode?: number): void;
    static readdir(path: string, cb?: (err: api_error.ApiError, files?: string[]) => void): void;
    static readdirSync(path: string): string[];
    static link(srcpath: string, dstpath: string, cb?: Function): void;
    static linkSync(srcpath: string, dstpath: string): void;
    static symlink(srcpath: string, dstpath: string, cb?: Function): void;
    static symlink(srcpath: string, dstpath: string, type?: string, cb?: Function): void;
    static symlinkSync(srcpath: string, dstpath: string, type?: string): void;
    static readlink(path: string, cb?: (err: api_error.ApiError, linkString: string) => any): void;
    static readlinkSync(path: string): string;
    static chown(path: string, uid: number, gid: number, cb?: Function): void;
    static chownSync(path: string, uid: number, gid: number): void;
    static lchown(path: string, uid: number, gid: number, cb?: Function): void;
    static lchownSync(path: string, uid: number, gid: number): void;
    static chmod(path: string, mode: string, cb?: Function): void;
    static chmod(path: string, mode: number, cb?: Function): void;
    static chmodSync(path: string, mode: string): void;
    static chmodSync(path: string, mode: number): void;
    static lchmod(path: string, mode: string, cb?: Function): void;
    static lchmod(path: string, mode: number, cb?: Function): void;
    static lchmodSync(path: string, mode: number): void;
    static lchmodSync(path: string, mode: string): void;
    static utimes(path: string, atime: number, mtime: number, cb: Function): void;
    static utimes(path: string, atime: Date, mtime: Date, cb: Function): void;
    static utimesSync(path: string, atime: number, mtime: number): void;
    static utimesSync(path: string, atime: Date, mtime: Date): void;
    static realpath(path: string, cb?: (err: api_error.ApiError, resolvedPath?: string) => any): void;
    static realpath(path: string, cache: {
        [path: string]: string;
    }, cb: (err: api_error.ApiError, resolvedPath?: string) => any): void;
    static realpathSync(path: string, cache?: {
        [path: string]: string;
    }): string;
}
export = fs;
